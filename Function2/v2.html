<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>游学路线规划</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@3"></script>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f4f4f9;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            margin: 0;
        }
        #network {
            width: 80%;
            height: 600px;
            border: 1px solid #ccc;
            margin: 20px auto;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .selector-wrapper {
            width: 80%;
            margin: 20px auto;
            background: white;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        select, input {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            box-sizing: border-box;
        }
        button {
            width: 100%;
            background-color: #0056b3;
            color: white;
            padding: 10px;
            margin-top: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #004494;
        }
        .highlighted {
            font-weight: bold;
            color: #d10000;
            background-color: #ffd2d2;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(209,0,0,0.2);
            text-align: center;
        }
        h1, h2 {
            text-align: center;
            color: #333;
        }
        .result-item, .statistics {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        .result-item:last-child, .statistics:last-child {
            border-bottom: none;
        }
        .no-results {
            text-align: center;
            color: #999;
        }
        .start-node {
            border: 3px solid #f00 !important;
        }
        .end-node {
            border: 3px solid #00f !important;
        }
        .path-edge {
            color: black !important;
            width: 3px !important;
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>游学路线规划</h1>
        <div class="selector-wrapper">
            <select v-model="selectedGraph" @change="loadGraph">
                <option v-for="graph in graphNames" :value="graph">{{ graph }}</option>
            </select>
        </div>
        <div class="selector-wrapper">
            <input type="text" v-model="startNodeSearch" placeholder="请输入出发地点...">
            <select v-model="selectedStartNode" @change="highlightStartNode">
                <option v-for="node in filteredStartNodes" :value="node">{{ node }}</option>
            </select>
            <input type="text" v-model="endNodeSearch" placeholder="请输入目的地点...">
            <select v-model="selectedEndNode" @change="highlightEndNode">
                <option v-for="node in filteredEndNodes" :value="node">{{ node }}</option>
            </select>
        </div>
        <div id="network"></div>
        <div class="selector-wrapper">
            <select v-model="selectedStrategy">
                <option value="distance">最短距离策略</option>
                <option value="time">最短时间策略</option>
            </select>
            <select v-model="selectedTransport" v-if="selectedStrategy === 'time'">
                <option value="walk">步行</option>
                <option value="bike">使用交通工具</option>
            </select>
        </div>
        <button @click="planRoute">规划路线</button>
        <div id="results">
            <h2>规划路线结果</h2>
            <div v-if="route.length > 0">
                <div v-for="(node, index) in route" :key="node" class="result-item">
                    {{ index + 1 }}. 地点名称：{{ node }}
                </div>
            </div>
            <div v-else class="no-results">
                在当前条件下没有结果
            </div>
        </div>
        <div id="statistics" class="selector-wrapper">
            <h2>统计信息</h2>
            <p>从出发点到目的地的总计距离：{{ totalDistance }} 米</p>
            <p v-if="selectedStrategy === 'time'">从出发点到目的地的总计时间：{{ (totalTime / 60).toFixed(2) }} 分钟</p>
            <p v-if="selectedStrategy === 'time' && selectedTransport === 'bike'">总步行时间：{{ (totalWalkTime / 60).toFixed(2) }} 分钟</p>
            <p v-if="selectedStrategy === 'time' && selectedTransport === 'bike'">总骑行时间：{{ (totalRideTime / 60).toFixed(2) }} 分钟</p>
        </div>
    </div>

    <script type="module">
    import { createApp, ref, computed, watch } from 'https://cdn.jsdelivr.net/npm/vue@3/dist/vue.esm-browser.js';
    import graph1 from './graph1.js';
    import graph2 from './graph2.js';
    import graph3 from './graph3.js';
    import graph4 from './graph4.js';
    import graph5 from './graph5.js';

    const graphs = { graph1, graph2, graph3, graph4, graph5 };

    createApp({
        setup() {
            const graphNames = ref(['graph1', 'graph2', 'graph3', 'graph4', 'graph5']);
            const selectedGraph = ref(graphNames.value[0]);
            const startNodeSearch = ref('');
            const endNodeSearch = ref('');
            const selectedStartNode = ref('');
            const selectedEndNode = ref('');
            const selectedStrategy = ref('distance');
            const selectedTransport = ref('walk');
            const network = ref(null);
            const route = ref([]);
            const totalDistance = ref(0);
            const totalTime = ref(0);
            const totalWalkTime = ref(0);
            const totalRideTime = ref(0);
            let previousHighlightedEdges = [];
            let previousEndNode = null;

            watch(selectedStartNode, () => highlightStartNode());
            watch(selectedEndNode, () => highlightEndNode());

            const filteredStartNodes = computed(() => {
                const nodes = graphs[selectedGraph.value];
                return startNodeSearch.value ? Object.keys(nodes).filter(node => node.toLowerCase().includes(startNodeSearch.value.toLowerCase())) : Object.keys(nodes);
            });

            const filteredEndNodes = computed(() => {
                const nodes = graphs[selectedGraph.value];
                return endNodeSearch.value ? Object.keys(nodes).filter(node => node.toLowerCase().includes(endNodeSearch.value.toLowerCase())) : Object.keys(nodes);
            });

            function loadGraph() {
                const nodes = [];
                const edges = [];
                const edgeSet = new Set();  // 防止重复添加边
                const graph = graphs[selectedGraph.value];
                for (let node in graph) {
                    nodes.push({ id: node, label: node, group: graph[node].node_category });
                    graph[node].edges.forEach(edge => {
                        const edgeId = node < edge.node ? node + '-' + edge.node : edge.node + '-' + node;
                        if (!edgeSet.has(edgeId)) {
                            edges.push({
                                id: edgeId,
                                from: node,
                                to: edge.node,
                                label: String(edge.distance),
                                color: edge.bike_flag ? 'blue' : 'red'
                            });
                            edgeSet.add(edgeId);
                        }
                    });
                }
                const container = document.getElementById('network');
                const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };
                const options = {};
                if (network.value) {
                    network.value.destroy();
                }
                network.value = new vis.Network(container, data, options);
                network.value.on("click", function (params) {
                    if (params.nodes.length > 0) {
                        const clickedNode = params.nodes[0];
                        selectedStartNode.value = clickedNode;
                    }
                });
                network.value.on("oncontext", function (params) {
                    params.event.preventDefault();
                    const pointer = params.pointer;
                    const clickedNode = network.value.getNodeAt(pointer.DOM);
                    if (clickedNode) {
                        if (previousEndNode) {
                            network.value.body.data.nodes.update({ id: previousEndNode, color: { border: '#2B7CE9' } });
                        }
                        selectedEndNode.value = clickedNode;
                        previousEndNode = clickedNode;
                    }
                });
            }

            function highlightStartNode() {
                if (network.value && selectedStartNode.value) {
                    network.value.body.data.nodes.update({ id: selectedStartNode.value, color: { border: 'black' } });
                    network.value.redraw();
                }
            }

            function highlightEndNode() {
                if (network.value && selectedEndNode.value) {
                    network.value.body.data.nodes.update({ id: selectedEndNode.value, color: { border: 'black' } });
                    network.value.redraw();
                }
            }

            function planRoute() {
                const graph = graphs[selectedGraph.value];
                const start = selectedStartNode.value;
                const end = selectedEndNode.value;

                if (!start || !end) return;

                const nodes = new Set(Object.keys(graph));
                const distances = {};
                const times = {};
                const previous = {};

                nodes.forEach(node => {
                    distances[node] = Infinity;
                    times[node] = Infinity;
                    previous[node] = null;
                });

                distances[start] = 0;
                times[start] = 0;

                while (nodes.size) {
                    const closestNode = [...nodes].reduce((minNode, node) =>
                        selectedStrategy.value === 'distance' ?
                        (distances[node] < distances[minNode] ? node : minNode) :
                        (times[node] < times[minNode] ? node : minNode)
                    , [...nodes][0]);

                    if (closestNode === end) break;

                    nodes.delete(closestNode);

                    graph[closestNode].edges.forEach(edge => {
                        const altDist = distances[closestNode] + edge.distance;
                        let altTime;
                        if (selectedTransport.value === 'walk') {
                            altTime = times[closestNode] + edge.time.walk_time;
                        } else {
                            altTime = times[closestNode] + (edge.time.ride_time === -1 ? edge.time.walk_time : Math.min(edge.time.walk_time, edge.time.ride_time));
                        }

                        if (selectedStrategy.value === 'distance' && altDist < distances[edge.node]) {
                            distances[edge.node] = altDist;
                            previous[edge.node] = closestNode;
                        } else if (selectedStrategy.value === 'time' && altTime < times[edge.node]) {
                            times[edge.node] = altTime;
                            previous[edge.node] = closestNode;
                        }
                    });
                }

                const path = [];
                let currentNode = end;
                totalDistance.value = 0;
                totalTime.value = 0;
                totalWalkTime.value = 0;
                totalRideTime.value = 0;

                while (currentNode) {
                    path.unshift(currentNode);
                    const prevNode = previous[currentNode];
                    if (prevNode) {
                        const edge = graph[prevNode].edges.find(e => e.node === currentNode);
                        totalDistance.value += edge.distance;
                        if (selectedStrategy.value === 'time') {
                            const time = selectedTransport.value === 'walk' ? edge.time.walk_time : (edge.time.ride_time !== -1 && edge.time.ride_time < edge.time.walk_time ? edge.time.ride_time : edge.time.walk_time);
                            totalTime.value += time;
                            if (selectedTransport.value === 'bike') {
                                totalWalkTime.value += edge.time.walk_time;
                                if (edge.time.ride_time !== -1) {
                                    totalRideTime.value += edge.time.ride_time;
                                }
                            }
                        }
                    }
                    currentNode = prevNode;
                }

                route.value = path;

                resetEdgeColors();
                highlightPath(path);
            }

            function resetEdgeColors() {
                if (network.value && previousHighlightedEdges.length > 0) {
                    const edges = network.value.body.data.edges.get();
                    previousHighlightedEdges.forEach(edgeId => {
                        const edge = edges.find(e => e.id === edgeId);
                        if (edge) {
                            edge.color = edge.bike_flag ? 'blue' : 'red';
                            edge.width = 1;
                        }
                    });
                    network.value.body.data.edges.update(edges);
                    previousHighlightedEdges = [];
                }
            }

            function highlightPath(path) {
                if (network.value) {
                    const edges = network.value.body.data.edges.get();
                    const updateEdges = edges.map(edge => {
                        if (path.includes(edge.from) && path.includes(edge.to)) {
                            previousHighlightedEdges.push(edge.id);
                            return { ...edge, color: { color: 'black' }, width: 3 };
                        } else {
                            return edge;
                        }
                    });
                    network.value.body.data.edges.update(updateEdges);

                    path.forEach((node, index) => {
                        if (index === 0 || index === path.length - 1) {
                            network.value.body.data.nodes.update({ id: node, color: { border: 'black' } });
                        } else {
                            network.value.body.data.nodes.update({ id: node, color: { border: 'green' } });
                        }
                    });
                }
            }

            return {
                graphNames, selectedGraph, network, startNodeSearch, endNodeSearch,
                selectedStartNode, selectedEndNode, selectedStrategy, selectedTransport,
                filteredStartNodes, filteredEndNodes, loadGraph, highlightStartNode, 
                highlightEndNode, planRoute, route, totalDistance, totalTime, totalWalkTime, totalRideTime
            };
        }
    }).mount('#app');
    </script>
</body>
</html>
